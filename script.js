// const cards = document.querySelectorAll(".card")

// const observer = new IntersectionObserver(entries => {
//     entries.forEach(entry =>{
//         entry.target.classList.toggle("show", entry.isIntersecting)

//         // the berlow commented code is for if you don't want the effect to be repetitive
//         // if (entry.isIntersecting) observer.unobserve(entry.target)
//         console.log(entries)
//     })
// }, {
//     // threshold: 1,
//     rootMargin:"-100px",
// })
// cards.forEach(card =>{
//     observer.observe(card)
// })

// const card2s = document.querySelectorAll(".card2")

// const observer1 = new IntersectionObserver(entries => {
//     entries.forEach(entry =>{
//         entry.target.classList.toggle("show", entry.isIntersecting)

//         // the berlow commented code is for if you don't want the effect to be repetitive
//         // if (entry.isIntersecting) observer.unobserve(entry.target)
//     })
// }, {
//     // threshold: 1,
//     rootMargin:"-100px",
// })
// card2s.forEach(card2 =>{
//     observer.observe(card2)
// })
// const txts = document.querySelectorAll(".txt")

// const observer2 = new IntersectionObserver(entries => {
//     entries.forEach(entry =>{
//         entry.target.classList.toggle("show", entry.isIntersecting)

//         // the berlow commented code is for if you don't want the effect to be repetitive
//         // if (entry.isIntersecting) observer.unobserve(entry.target)
//     })
// }, {
//     // threshold: 1,
//     rootMargin:"100px",
// })
// txts.forEach(txt =>{
//     observer.observe(txt)
// })

const s1 = document.querySelectorAll(".s1")

const observer = new IntersectionObserver(entries => {
    entries.forEach(entry =>{
        entry.target.classList.toggle("show", entry.isIntersecting)

        // the berlow commented code is for if you don't want the effect to be repetitive
        // if (entry.isIntersecting) observer.unobserve(entry.target)
        console.log(entries)
    })
}, {
    // threshold: 1,
    rootMargin:"-100px",
})
s1.forEach(s1 =>{
    observer.observe(s1)
})

const s2 = document.querySelectorAll(".s2")

const observer22 = new IntersectionObserver(entries => {
    entries.forEach(entry =>{
        entry.target.classList.toggle("show", entry.isIntersecting)

        // the berlow commented code is for if you don't want the effect to be repetitive
        // if (entry.isIntersecting) observer.unobserve(entry.target)
        console.log(entries)
    })
}, {
    // threshold: 1,
    rootMargin:"-100px",
})
s2.forEach(s2 =>{
    observer.observe(s2)
})

const s3 = document.querySelectorAll(".s3")

const observer33 = new IntersectionObserver(entries => {
    entries.forEach(entry =>{
        entry.target.classList.toggle("show", entry.isIntersecting)

        // the berlow commented code is for if you don't want the effect to be repetitive
        // if (entry.isIntersecting) observer.unobserve(entry.target)
        console.log(entries)
    })
}, {
    // threshold: 1,
    rootMargin:"-100px",
})
s3.forEach(s3 =>{
    observer.observe(s3)
})

const s4 = document.querySelectorAll(".s4")

const observer44 = new IntersectionObserver(entries => {
    entries.forEach(entry =>{
        entry.target.classList.toggle("show", entry.isIntersecting)

        // the berlow commented code is for if you don't want the effect to be repetitive
        // if (entry.isIntersecting) observer.unobserve(entry.target)
        console.log(entries)
    })
}, {
    // threshold: 1,
    rootMargin:"-100px",
})
s4.forEach(s4 =>{
    observer.observe(s4)
})

const the = document.querySelectorAll(".the")

const observer55 = new IntersectionObserver(entries => {
    entries.forEach(entry =>{
        entry.target.classList.toggle("show", entry.isIntersecting)

        // the berlow commented code is for if you don't want the effect to be repetitive
        // if (entry.isIntersecting) observer.unobserve(entry.target)
        console.log(entries)
    })
}, {
    // threshold: 1,
    rootMargin:"-100px",
})
the.forEach(the =>{
    observer.observe(the)
})